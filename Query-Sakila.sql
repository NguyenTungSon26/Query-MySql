-- LEVEL 1

-- 1.1: Write a SQL query to return the first and last names of all actors in the database.
-- Viết truy vấn SQL để trả về họ và tên của tất cả các diễn viên trong cơ sở dữ liệu.

SELECT first_name, last_name 
FROM actor;

-- 1.2: Write a SQL query to return the titles of all films in the database, along with their rental rates and replacement costs.
-- Viết một truy vấn SQL để trả về tiêu đề của tất cả các bộ phim trong cơ sở dữ liệu, cùng với giá thuê và chi phí thay thế của chúng.

SELECT title, rental_rate, replacement_cost 
FROM film;

-- 1.3: Write a SQL query to return the top 5 most rented films in the database, along with the number of times they have been rented.
-- Viết truy vấn SQL để trả về 5 bộ phim được thuê nhiều nhất trong cơ sở dữ liệu, cùng với số lần chúng được thuê.

SELECT f.title AS "Films", COUNT(r.rental_id) AS "Number of rentals" 
FROM film f
JOIN inventory i ON i.film_id = f.film_id
JOIN rental r ON r.inventory_id = i.inventory_id
GROUP BY f.title
ORDER BY COUNT(r.rental_id) DESC
LIMIT 5;

-- 1.4: Write a SQL query to return the average rental duration for each category of film in the database.
-- Viết truy vấn SQL để trả về thời lượng thuê trung bình cho từng danh mục phim trong cơ sở dữ liệu.

SELECT c.name AS "Category", AVG(TIMESTAMPDIFF(DAY, r.rental_date, r.return_date)) AS "Average duration"
FROM category c
JOIN film_category fc ON c.category_id = fc.category_id
JOIN film f ON fc.film_id = f.film_id
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
GROUP BY c.category_id;

-- 1.5(error vì chỉ có film thuê trong năm 2005): Write a SQL query to return the names and addresses of all customers who have rented a film in the month of January 2022 
-- Viết truy vấn SQL để trả về tên và địa chỉ của tất cả khách hàng đã thuê phim trong tháng 1 năm 2022.

SELECT c.first_name, c.last_name, a.address
FROM customer c
JOIN address a ON c.address_id = a.address_id
JOIN rental r ON r.customer_id = c.customer_id
WHERE r.rental_date BETWEEN '2005-05-01 00:00:00' AND '2005-05-31 23:59:59';

-- 1.6: Write a SQL query to return the revenue generated by each store in the database for the year 2005 
-- Viết truy vấn SQL để trả về doanh thu do mỗi cửa hàng tạo ra trong cơ sở dữ liệu cho năm 2005.

SELECT s.store_id, SUM(p.amount) AS revenue
FROM store s
-- Join bảng staff lấy ID nhân viên được liên kết với từng store
JOIN staff st ON st.store_id = s.store_id
-- Join bảng payment để lấy số $ thanh toán của từng nhân viên
JOIN payment p ON p.staff_id = st.staff_id
-- Lọc kết quả gồm các khoản thanh toán được thực hiện trong năm 2005
WHERE year(p.payment_date) = 2005
-- Nhóm kết quả theo ID store -> tính tổng doanh thu cho từng cửa hàng
GROUP BY s.store_id; 

-- 1.7: Write a SQL query to return the names of all actors who have appeared in more than 20 films in the database.
-- Viết truy vấn SQL để trả về tên của tất cả các diễn viên đã xuất hiện trong hơn 20 bộ phim trong cơ sở dữ liệu.

SELECT a.first_name, a.last_name, COUNT(*) AS film_count
FROM actor a
-- Join bảng film_actor để lấy all các bộ phim được link với từng diễn viên
JOIN film_actor fa ON a.actor_id = fa.actor_id
-- Nhóm kết quả theo ID diễn viên -> count số lượng phim cho từng diễn viên
GROUP BY a.actor_id
-- Lọc kết quả gồm các diễn viên đã đóng trên 20 phim
HAVING COUNT(*) > 20;

-- 1.8: Write a SQL query to return the titles of all films in the database that have a rating of 'PG-13' and a length of more than 120 minutes.
-- Viết truy vấn SQL để trả về tiêu đề của tất cả các phim trong cơ sở dữ liệu có xếp hạng 'PG-13' và thời lượng hơn 120 phút.

SELECT title
FROM film
-- Lọc phim có xếp hạng 'PG-13'
WHERE rating = 'PG-13'
-- Lọc phim gồm những phim có thời lượng lớn hơn 120 phút
AND length > 120;

-- LEVEL 2:

-- 2.1: Write a SQL query to return the top 10 customers who have generated the most revenue for the store, including their names and total revenue generated.
-- Viết truy vấn SQL để trả về 10 khách hàng hàng đầu đã tạo ra nhiều doanh thu nhất cho cửa hàng, bao gồm tên của họ và tổng doanh thu được tạo ra.

-- Chọn họ, tên và tổng doanh thu cho top 10 khách hàng theo doanh thu
SELECT c.first_name, c.last_name, SUM(p.amount) AS total_revenue
FROM customer c
-- Join bảng cho thuê nhận tất cả các dịch vụ cho thuê được link với từng khách hàng
JOIN rental r ON c.customer_id = r.customer_id
-- Join bảng thanh toán nhận tất cả các khoản thanh toán liên quan đến mỗi lần thuê
JOIN payment p ON r.rental_id = p.rental_id
-- Nhóm kết quả theo ID khách hàng -> tính tổng doanh thu từng khách hàng
GROUP BY c.customer_id
-- Sắp xếp result theo thứ tự tổng doanh thu giảm dần theo 10 khách hàng hàng đầu
ORDER BY total_revenue DESC
-- Hiển thị cho 10 khách hàng hàng đầu theo doanh thu
LIMIT 10;

-- 2.2: Write a SQL query to return the names and contact information of all customers who have rented films in all categories in the database.
-- Viết truy vấn SQL để trả về tên và thông tin liên hệ của tất cả khách hàng đã thuê phim ở tất cả các danh mục trong cơ sở dữ liệu.

SELECT c.first_name, c.last_name, c.email, a.address, a.phone
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
JOIN address a ON a.address_id = c.address_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN film_category fc ON i.film_id = fc.film_id
JOIN category cate ON fc.category_id = cate.category_id
-- Nhóm các kết quả theo ID khách hàng đếm số lượng danh mục mỗi khách hàng đã thuê phim
GROUP BY c.customer_id
-- Lọc kết quả gồm những khách hàng đã thuê phim ở tất cả các danh mục
HAVING COUNT(DISTINCT cate.category_id) = (SELECT COUNT(*) FROM category);

-- 2.3: Write a SQL query to return the titles of all films in the database that have been rented at least once but never returned.
-- Viết truy vấn SQL để trả về tiêu đề của tất cả các phim trong cơ sở dữ liệu đã được thuê ít nhất một lần nhưng không bao giờ trả lại.

SELECT f.title
FROM film f
JOIN inventory i ON f.film_id = i.film_id
JOIN rental r ON i.inventory_id = r.inventory_id
-- Lọc result để chỉ bao gồm các dịch vụ cho thuê chưa được trả lại
WHERE r.return_date IS NULL;

-- 2.4: Write a SQL query to return the names of all actors who have appeared in at least one film in each category in the database.
-- Viết truy vấn SQL để trả về tên của tất cả các diễn viên đã xuất hiện trong ít nhất một bộ phim trong mỗi danh mục trong cơ sở dữ liệu.

-- chọn tên và họ của các diễn viên đã đóng phim từ tất cả các thể loại
SELECT actor.first_name, actor.last_name 
FROM actor 
-- JOIN bảng diễn viên với bảng film_actor trên actor_id
JOIN film_actor ON actor.actor_id = film_actor.actor_id 
-- JOIN bảng film_actor với bảng film_category trên film_id
JOIN film_category ON film_actor.film_id = film_category.film_id 
-- nhóm kết quả theo actor_id
GROUP BY actor.actor_id 
-- lọc các diễn viên đã đóng phim từ tất cả các danh mục
HAVING COUNT(DISTINCT film_category.category_id) = (
  -- sub query lấy tổng số danh mục
  SELECT COUNT(*) FROM category
);

-- 2.5: Write a SQL query to return the names of all customers who have rented the same film more than once in a single transaction, along with the number of times they rented it.
-- Viết một truy vấn SQL để trả về tên của tất cả các khách hàng đã thuê cùng một bộ phim nhiều lần trong một giao dịch, cùng với số lần họ đã thuê bộ phim đó.

SELECT c.first_name, c.last_name, COUNT(*) as rental_count
FROM customer c
-- JOIN bảng rental và inventory để lấy thông tin về các thuê bao và bộ phim tương ứng.
JOIN rental r1 ON c.customer_id = r1.customer_id
-- JOIN lại bảng rental một lần nữa  chỉ lấy các thuê bao có cùng ngày thuê nhưng khác rental_id -> loại bỏ bản ghi trùng lặp.
JOIN rental r2 ON r1.customer_id = r2.customer_id AND r1.rental_id <> r2.rental_id AND r1.rental_date = r2.rental_date
JOIN inventory i ON r1.inventory_id = i.inventory_id
-- Nhóm theo customer_id để tính tổng số lượng thuê của mỗi khách hàng.
GROUP BY c.customer_id
-- chỉ chọn các khách hàng có ít nhất hai thuê trong kết quả truy vấn.
HAVING rental_count > 1;

-- 2.6: Write a SQL query to return the total revenue generated by each actor in the database, based on the rental fees of the films they have appeared in.
-- Viết truy vấn SQL để trả về tổng doanh thu do mỗi diễn viên tạo ra trong cơ sở dữ liệu, dựa trên phí thuê phim mà họ đã xuất hiện.

SELECT actor.actor_id, actor.first_name, actor.last_name, 
-- tổng doanh thu cho mỗi diễn viên và đặt kết quả là total_revenue
  SUM(payment.amount) AS total_revenue 
FROM 
  actor 
-- JOIN bảng film_actor trên cột ID diễn viên để connect giữa diễn viên và phim
JOIN film_actor ON actor.actor_id = film_actor.actor_id 
-- JOIN bảng phim trên cột ID phim để lấy thông tin về phim
JOIN film ON film_actor.film_id = film.film_id 
-- JOIN bảng tồn kho trên cột ID phim để lấy thông tin tồn kho của từng phim
JOIN inventory ON film.film_id = inventory.film_id 
-- JOIN bảng cho thuê trên các cột ID hàng tồn kho lấy thông tin những lần cho thuê
JOIN rental ON inventory.inventory_id = rental.inventory_id 
-- JOIN bảng thanh toán trên các cột ID cho thuê lấy thông tin các khoản thanh toán đã được thực hiện
JOIN payment ON rental.rental_id = payment.rental_id 
-- Nhóm các kết quả theo diễn viên để tổng hợp số $ thanh toán theo diễn viên
GROUP BY actor.actor_id, actor.first_name, actor.last_name 
-- Sắp xếp tổng doanh thu theo thứ tự giảm dần
ORDER BY total_revenue DESC;

-- 2.7: Write a SQL query to return the names of all actors who have appeared in at least one film with a rating of 'R', but have never appeared in a film with a rating of 'G'.
-- Viết một truy vấn SQL để trả về tên của tất cả các diễn viên đã xuất hiện trong ít nhất một bộ phim có xếp hạng 'R', nhưng chưa bao giờ xuất hiện trong một bộ phim có xếp hạng 'G'.

SELECT actor.first_name, actor.last_name
FROM actor
-- JOIN bảng diễn viên với bảng film_actor trên actor_id để tìm tất cả các phim diễn viên đã xuất hiện
JOIN film_actor ON actor.actor_id = film_actor.actor_id
-- JOIN bảng film_actor với bảng phim trên film_id lấy xếp hạng của từng phim
JOIN film ON film_actor.film_id = film.film_id
-- lọc những bộ phim có xếp hạng 'R'
WHERE film.rating = 'R'
-- Loại các diễn viên đã xuất hiện trong phim có xếp hạng 'G'
AND actor.actor_id NOT IN (
  -- Sub query: Chọn actor_id các diễn viên đã xuất hiện trong phim có xếp hạng 'G'
  SELECT actor.actor_id
  FROM actor
  -- JOIN bảng diễn viên với bảng film_actor trên actor_id để tìm tất cả các phim mà mỗi diễn viên đã xuất hiện
  JOIN film_actor ON actor.actor_id = film_actor.actor_id
  -- JOIN bảng film_actor với bảng phim trên film_id để lấy xếp hạng của từng phim
  JOIN film ON film_actor.film_id = film.film_id
  -- Chỉ lọc những bộ phim có xếp hạng 'G'
  WHERE film.rating = 'G'
)
-- Nhóm các kết quả theo actor_id, first_name và last_name loại bỏ các kết quả trùng lặp
GROUP BY actor.actor_id, actor.first_name, actor.last_name;

-- 2.8 : Write a SQL query to return the titles of all films in the database that have been rented by more than 50 customers, but have never been rented by the same customer more than once.
-- Viết truy vấn SQL để trả về tiêu đề của tất cả các phim trong cơ sở dữ liệu đã được thuê bởi hơn 50 khách hàng, nhưng chưa bao giờ được thuê bởi cùng một khách hàng nhiều lần.

SELECT film.title, film.film_id
FROM film
-- JOIN bảng phim với bảng tồn kho trên film_id để tìm các bản sao của mỗi phim
JOIN inventory ON film.film_id = inventory.film_id
-- JOIN bảng tồn kho với bảng cho thuê trên inventory_id để tìm tất cả các bản cho thuê của từng bản sao film
JOIN rental ON inventory.inventory_id = rental.inventory_id
GROUP BY film.film_id
-- lọc phim đã thuê bởi ít nhất 30 KH duy nhất và không có phim cho thuê quá hạn
HAVING COUNT(DISTINCT rental.customer_id) > 30
   AND COUNT(DISTINCT rental.customer_id) = COUNT(*);

-- 2.9: Write a SQL query to return the names of all customers who have rented a film from a category they have never rented from before.
-- Viết truy vấn SQL để trả về tên của tất cả các khách hàng đã thuê phim từ danh mục mà họ chưa từng thuê trước đây.

SELECT DISTINCT customer.first_name, customer.last_name
FROM customer
JOIN rental ON customer.customer_id = rental.customer_id
JOIN inventory ON rental.inventory_id = inventory.inventory_id
JOIN film ON inventory.film_id = film.film_id
JOIN film_category ON film.film_id = film_category.film_id
JOIN category ON film_category.category_id = category.category_id
WHERE NOT EXISTS (
  -- subquery kiểm tra có tồn tại danh mục mà khách hàng chưa thuê phim từ đó không
  SELECT *
  FROM category
  WHERE NOT EXISTS (
    -- subquery kiểm tra khách hàng đã thuê phim từ một danh mục nhất định chưa
    SELECT *
    FROM film_category
    JOIN inventory ON film_category.film_id = inventory.film_id
    JOIN rental ON inventory.inventory_id = rental.inventory_id
    WHERE rental.customer_id = customer.customer_id
    AND category.category_id = film_category.category_id
  )
);

-- 2.10: Write a SQL query to return the titles of all films in the database that have been rented by every customer who has ever rented a film from the 'Action' category.
-- Viết truy vấn SQL để trả về tiêu đề của tất cả các phim trong cơ sở dữ liệu đã được thuê bởi mọi khách hàng đã từng thuê phim từ danh mục 'Hành động'.

SELECT DISTINCT f.title 
FROM film f
  JOIN inventory i ON f.film_id = i.film_id 
  JOIN rental r ON i.inventory_id = r.inventory_id 
  JOIN customer c ON r.customer_id = c.customer_id 
  JOIN film_category fc ON f.film_id = fc.film_id 
  JOIN category ca ON fc.category_id = ca.category_id 
-- lọc kết quả trên danh mục hành động
WHERE ca.name = 'Action'  
-- lọc kết quả trên subquery
  AND c.customer_id IN ( 
    SELECT DISTINCT c.customer_id 
    FROM customer c 
      JOIN rental r ON c.customer_id = r.customer_id 
      JOIN inventory i ON r.inventory_id = i.inventory_id 
      JOIN film f ON i.film_id = f.film_id 
      JOIN film_category fc ON f.film_id = fc.film_id
      JOIN category ca ON fc.category_id = ca.category_id
	-- lọc kết quả trên danh mục hành động
    WHERE ca.name = 'Action' 
  );

-- LEVEL 3:

-- 3.1:  Write a SQL query to return the average rental duration for each combination of actor and category in the database sakila, excluding actors who have not appeared in any films in a category.
-- Viết truy vấn SQL để trả về thời lượng thuê trung bình cho từng tổ hợp diễn viên và danh mục trong cơ sở dữ liệu, ngoại trừ các diễn viên chưa xuất hiện trong bất kỳ bộ phim nào trong danh mục.

SELECT a.actor_id, c.name AS category_name, AVG(DATEDIFF(return_date, rental_date)) AS avg_rental_duration
FROM  actor a 
    JOIN film_actor fa ON a.actor_id = fa.actor_id 
    JOIN film_category fc ON fa.film_id = fc.film_id 
    JOIN category c ON fc.category_id = c.category_id 
    JOIN inventory i ON fc.film_id = i.film_id 
    JOIN rental r ON i.inventory_id = r.inventory_id 
-- lọc các diễn viên đã đóng phim ít nhất một thể loại
WHERE a.actor_id IN (
        SELECT fa.actor_id
        FROM film_actor fa
        JOIN film_category fc ON fa.film_id = fc.film_id
        GROUP BY fa.actor_id
        HAVING COUNT(DISTINCT fc.category_id) > 0
    )
-- nhóm kết quả theo actor_id và category_id
GROUP BY a.actor_id, c.category_id;
    
-- 3.2: Write a SQL query to database sakila and return the names of all actors who have appeared in a film with a rating of 'R' and a length of more than 2 hours, but have never appeared in a film with a rating of 'G'
-- Viết truy vấn SQL tới cơ sở dữ liệu sakila và trả về tên của tất cả các diễn viên đã xuất hiện trong phim có xếp hạng 'R' và thời lượng hơn 2 giờ, nhưng chưa từng xuất hiện trong phim có xếp hạng 'G'

SELECT a.first_name, a.last_name
FROM actor a
JOIN film_actor fa ON a.actor_id = fa.actor_id
JOIN film  f ON fa.film_id = f.film_id
JOIN film_category fc ON f.film_id = fc.film_id
JOIN category c ON fc.category_id = c.category_id
-- Lọc kết quả chỉ chọn những phim được xếp hạng R dài hơn 120 phút
WHERE f.rating = 'R' AND f.length > 120
-- Loại các diễn viên đã đóng phim xếp hạng G
AND a.actor_id NOT IN (
-- subquery chọn diễn viên đã đóng phim được xếp hạng G
SELECT DISTINCT actor.actor_id
FROM actor
JOIN film_actor ON actor.actor_id = film_actor.actor_id
JOIN film ON film_actor.film_id = film.film_id
JOIN film_category ON film.film_id = film_category.film_id
JOIN category ON film_category.category_id = category.category_id
-- Lọc kết quả chỉ chọn phim được xếp hạng G
WHERE film.rating = 'G'
);

-- 3.3: Write a SQL query to database sakila return the names of all customers who have rented more than 10 films in a single transaction, along with the number of films they rented and the total rental fee.
-- Viết truy vấn SQL để cơ sở dữ liệu trả về tên của tất cả khách hàng đã thuê hơn 10 bộ phim trong một giao dịch, cùng với số lượng phim họ đã thuê và tổng phí thuê.

SELECT c.first_name,  c.last_name, 
-- đếm số lần cho thuê được thực hiện bởi khách hàng
COUNT(*) as number_of_rentals,  
-- tính tổng phí thuê khách hàng đã thanh toán
SUM(p.amount) as total_rental_fee 
FROM customer c  
INNER JOIN payment p ON c.customer_id = p.customer_id  
INNER JOIN rental r ON p.rental_id = r.rental_id 
-- nhóm kết quả theo id khách hàng
GROUP BY c.customer_id  
-- chỉ gồm khách hàng đã thực hiện hơn 10 lần thuê
HAVING COUNT(*) > 10;  

-- 3.4: Write a SQL query to return the names of all customers who have rented every film in a category, along with the total number of films rented and the total rental fee.
-- Viết một truy vấn SQL để trả về tên của tất cả các khách hàng đã thuê mọi bộ phim trong một danh mục, cùng với tổng số phim đã thuê và tổng phí thuê.

SELECT CONCAT(c.first_name, ' ', c.last_name) AS full_name, COUNT(*) AS total_rentals, SUM(f.rental_rate) AS total_fees
FROM customer c
JOIN rental r ON c.customer_id = r.customer_id
JOIN inventory i ON r.inventory_id = i.inventory_id
JOIN film f ON i.film_id = f.film_id
JOIN film_category fc ON f.film_id = fc.film_id
JOIN category ca ON fc.category_id = ca.category_id
-- Nhóm kết quả theo tên đầy đủ của khách hàng 
GROUP BY full_name
-- Loại bất kỳ khách hàng nào chưa thuê phim
HAVING total_rentals > 0;

-- 3.5 (error): Write a SQL query to return the titles of all films in the database that have been rented by the same customer more than once in a single day, along with the names of the customers who rented them and the number of times they were rented.
-- Viết truy vấn SQL để trả về tiêu đề của tất cả các phim trong cơ sở dữ liệu đã được cùng một khách hàng thuê nhiều lần trong một ngày, cùng với tên của những khách hàng đã thuê phim và số lần họ được thuê.

SELECT f.title, c.first_name, c.last_name, COUNT(*) AS rental_count
FROM rental r
INNER JOIN inventory i ON r.inventory_id = i.inventory_id
INNER JOIN film f ON i.film_id = f.film_id
INNER JOIN customer c ON r.customer_id = c.customer_id

GROUP BY f.title, c.first_name, c.last_name
HAVING rental_count > 1;

-- Xác định bản ghi cho thuê có cùng customer_id, inventory_id và rental_date.
SELECT customer_id, inventory_id, rental_date, COUNT(*) as num_rentals
FROM rental
GROUP BY customer_id, inventory_id, rental_date
HAVING COUNT(*) > 0;

-- 3.7: Write a SQL query to return the names of all customers who have rented at least one film from each category in the database sakila, along with the number of films rented from each category.
-- Viết truy vấn SQL để trả về tên của tất cả các khách hàng đã thuê ít nhất một bộ phim từ mỗi danh mục trong cơ sở dữ liệu sakila, cùng với số lượng phim đã thuê từ mỗi danh mục.

SELECT c.first_name,c.last_name,
-- Đếm số lượng giá trị theo id trong bảng rental mỗi khách hàng và as = 'total_rentals'
    COUNT(r.rental_id) AS total_rentals,
-- Đếm số lượng giá trị category_id duy nhất trong bảng phim mỗi khách hàng và as = 'total_categories'
    COUNT(DISTINCT f.category_id) AS total_categories
FROM customer c
    INNER JOIN rental r ON c.customer_id = r.customer_id
    INNER JOIN inventory i ON r.inventory_id = i.inventory_id
    INNER JOIN film_category f ON i.film_id = f.film_id
-- Chỉ chọn những danh mục tồn tại trong bảng danh mục
WHERE f.category_id IN (
        SELECT category_id 
        FROM category
    )
-- Nhóm theo customer_id để có tổng số
GROUP BY c.customer_id
-- Check số lượng danh mục riêng biệt khách hàng đã thuê có bằng tổng số danh mục trong bảng danh mục không
HAVING COUNT(DISTINCT f.category_id) = (
        SELECT COUNT(*) 
        FROM category
    )
-- Sắp xếp theo tổng số tiền thuê theo thứ tự giảm dần
ORDER BY total_rentals DESC;

-- 3.8: Write a SQL query to return the titles of all films in the database sakila that have been rented more than 100 times, but have never been rented by any customer who has rented a film with a rating of 'G'.
-- Viết truy vấn SQL để trả về tiêu đề của tất cả các phim trong cơ sở dữ liệu sakila đã được thuê hơn 100 lần nhưng chưa bao giờ được thuê bởi bất kỳ khách hàng nào đã thuê phim có xếp hạng 'G'.

SELECT title
FROM film
-- Phim không được xếp hạng 'G'
WHERE film_id NOT IN (
  SELECT inventory.film_id
  FROM inventory
  JOIN rental ON inventory.inventory_id = rental.inventory_id
  JOIN customer ON rental.customer_id = customer.customer_id
  JOIN film ON inventory.film_id = film.film_id
  WHERE film.rating = 'G'
)
-- Bộ phim phải được thuê hơn 10 lần
AND film_id IN (
  SELECT inventory.film_id
  FROM inventory
  JOIN rental ON inventory.inventory_id = rental.inventory_id
  GROUP BY inventory.film_id
  HAVING COUNT(*) > 30
);

-- kiểm tra số lần cho thuê của mỗi bộ phim
SELECT film.title, COUNT(rental.rental_id) as rental_count
FROM film
JOIN inventory ON film.film_id = inventory.film_id
JOIN rental ON inventory.inventory_id = rental.inventory_id
GROUP BY film.film_id
HAVING COUNT(*) > 30;
-- Kết quả trả về sẽ là danh sách các bộ phim đã được cho thuê nhiều hơn 10 lần và số lần cho thuê của mỗi bộ phim.

-- 3.9: Write a SQL query to return the names of all customers who have rented a film from a category they have never rented from before, and have also never rented a film longer than 3 hours.
-- Viết truy vấn SQL để trả về tên của tất cả các khách hàng đã thuê phim từ danh mục mà họ 
-- chưa bao giờ thuê trước đây và cũng chưa bao giờ thuê phim dài hơn 3 giờ.

-- Test
-- Query xem các bộ phim có độ dài nhỏ hơn hoặc bằng <=3h
SELECT count(*)
FROM film
WHERE length <= 180;

-- Return records của các bộ phim có độ dài nhỏ hơn hoặc bằng 180 phút.
SELECT *
FROM rental AS r
JOIN inventory AS i ON r.inventory_id = i.inventory_id
JOIN film AS f ON i.film_id = f.film_id
WHERE f.length <= 180;

-- Code run
SELECT DISTINCT customer.first_name, customer.last_name
FROM customer
JOIN rental ON rental.customer_id = customer.customer_id
JOIN inventory ON rental.inventory_id = inventory.inventory_id
JOIN film ON inventory.film_id = film.film_id
-- Lọc phim có độ dài nhỏ hơn hoặc bằng 180 phút
WHERE film.length <= 180 
AND customer.customer_id NOT IN (
    SELECT DISTINCT rental.customer_id
    FROM rental
    JOIN inventory ON rental.inventory_id = inventory.inventory_id
    JOIN film_category ON inventory.film_id = film_category.film_id
    WHERE film_category.category_id NOT IN (
        SELECT DISTINCT film_category.category_id
        FROM rental
        JOIN inventory ON rental.inventory_id = inventory.inventory_id
        JOIN film_category ON inventory.film_id = film_category.film_id
        WHERE rental.customer_id = customer.customer_id
    )
);

-- 3.10: Write a SQL query to return the names of all actors who have appeared in a film with a rating of 'PG-13' and a length of more than 2 hours, and have also appeared in a film with a rating of 'R' and a length of less than 90 minutes.
-- Viết truy vấn SQL để trả về tên của tất cả các diễn viên đã xuất hiện trong một bộ phim có xếp hạng 'PG-13' và thời lượng hơn 2 giờ, đồng thời cũng đã xuất hiện trong một bộ phim có xếp hạng 'R' và thời lượng dưới 90 phút.

SELECT DISTINCT actor.first_name, actor.last_name
FROM actor 
INNER JOIN film_actor ON actor.actor_id = film_actor.actor_id
INNER JOIN film ON film.film_id = film_actor.film_id
WHERE film.rating = 'PG-13' AND film.length > 120
AND actor.actor_id IN (
	SELECT film_actor.actor_id
	FROM film_actor
	INNER JOIN film ON film.film_id = film_actor.film_id
	WHERE film.rating = 'R' AND film.length < 90
);

-- LEVEL 4:

-- 4.1: Write a SQL query to update the rental rate of all films in the database sakila that have been rented more than 100 times, setting the new rental rate to be 10% higher than the current rate.
-- Viết truy vấn SQL để cập nhật giá thuê của tất cả các phim trong cơ sở dữ liệu sakila đã được thuê hơn 100 lần, đặt giá thuê mới cao hơn 10% so với giá hiện tại.

UPDATE film 
-- Nhân tỷ lệ cho thuê hiện tại với 2
SET rental_rate = rental_rate * 1.1
-- Lọc các phim sẽ được cập nhật bằng truy vấn phụ
WHERE film_id IN (
  -- Chọn tất cả film_ids từ hàng tồn kho đã được thuê hơn 100 lần
  SELECT inventory.film_id 
  FROM rental
  JOIN inventory ON rental.inventory_id = inventory.inventory_id
  -- Nhóm kho theo film_id và chỉ bao gồm những kho có hơn 100 phim cho thuê
  GROUP BY inventory.film_id 
  HAVING COUNT(*) > 100
);

-- 4.2: Write a SQL query to update the rental duration of all films in the database sakila that have been rented more than 5 times, setting the new duration to be 5% longer than the current duration.
-- Viết truy vấn SQL để cập nhật thời lượng thuê của tất cả các phim trong cơ sở dữ liệu đã được thuê hơn 5 lần, đặt thời lượng mới dài hơn 5% so với thời lượng hiện tại.

UPDATE film 
-- Nhân thời hạn thuê hiện tại với 1,1 và làm tròn kết quả
SET rental_duration = ROUND(rental_duration * 1.1) 
-- Lọc các phim sẽ được cập nhật bằng truy vấn phụ
WHERE film_id IN (
  -- Chọn tất cả film_ids từ các phim cho thuê đã được thuê hơn 5 lần
  SELECT film_id 
  FROM rental 
  -- Nhóm các video cho thuê theo film_id và chỉ bao gồm những video có số lượng hơn 5 video cho thuê
  GROUP BY film_id 
  HAVING COUNT(rental_id) > 5
);

SELECT film_id, rental_duration
FROM film
WHERE film_id IN
    (SELECT film_id
     FROM rental
     GROUP BY film_id
     HAVING COUNT(rental_id) > 5);

-- 4.3: Write a SQL query to update the rental rate of all films in the 'Action' category that were released before the year 2005, setting the new rate to be 20% higher than the current rate.

UPDATE film f
INNER JOIN film_category fc ON f.film_id = fc.film_id
INNER JOIN category c ON fc.category_id = c.category_id
SET f.rental_rate = f.rental_rate * 1.2
WHERE c.name = 'Action' AND f.release_year < 2005;

-- 4.4: error Write a SQL query to update the email address of all customers who have rented a film from the 'Horror' category in the month of October 2022, setting the new email address to be a combination of their current email address and the string 'horrorlover'.

UPDATE customer
SET email = CONCAT(email, 'horrorlover')
WHERE customer_id IN (
  SELECT rental.customer_id
  FROM rental
  JOIN inventory ON rental.inventory_id = inventory.inventory_id
  JOIN film ON inventory.film_id = film.film_id
  JOIN film_category ON film.film_id = film_category.film_id
  JOIN category ON film_category.category_id = category.category_id
  WHERE category.name = 'Horror' 
    AND MONTH(rental.return_date) = 10
    AND YEAR(rental.return_date) = 2021
);

-- 4.5 error: Write a SQL query to update the rental rate of all films in the database that have been rented by more than 10 customers, setting the new rate to be 5% higher than the current rate, but not higher than $4.00.
UPDATE film
SET rental_rate = LEAST(rental_rate * 1.05, 4.00)
WHERE film_id IN (
  SELECT inventory.film_id
  FROM rental
  JOIN inventory ON rental.inventory_id = inventory.inventory_id
  GROUP BY inventory.film_id
  HAVING COUNT(DISTINCT rental.customer_id) > 10
);

-- 4.6: Write a SQL query to update the rental rate of all films in the database sakila that have a rating of 'PG-13' and a length of more than 2 hours, setting the new rate to be $3.50.

UPDATE film
SET rental_rate = 3.50
WHERE rating = 'PG-13' AND length > 120;

-- 4.7: Write a SQL query to update the rental duration of all films in the 'Sci-Fi' category that were released in the year 2010, setting the new duration to be equal to the length of the film in minutes.

UPDATE film
SET rental_duration = length
WHERE category_id = (
    SELECT category_id FROM category WHERE name = 'Sci-Fi'
) AND YEAR(release_year) = 2010;

UPDATE film
SET rental_duration = length
WHERE category_id = (
    SELECT category_id FROM category WHERE name = 'Sci-Fi'
) AND YEAR(release_year) = 2010;


-- 4.8:error Write a SQL query to update the address of all customers who live in the same city as another customer with the same last name, setting the new address to be the concatenation of their current address and the string 'samecity'.
UPDATE customer c1
JOIN customer c2
ON c1.city = c2.city AND c1.last_name = c2.last_name AND c1.customer_id != c2.customer_id
SET c1.address = CONCAT(c1.address, 'samecity');

-- 4.9:error Write a SQL query to the database sakila update the rental rate of all films in the 'Comedy' category that were released in the year 2007 or later, setting the new rate to be 15% lower than the current rate.
UPDATE film
SET rental_rate = rental_rate * 0.85
WHERE category_id = (
  SELECT category_id FROM category WHERE name = 'Comedy'
) AND release_year >= 2007;

-- 4.10: Write a SQL query to update the rental rate of all films in the database sakila that have a rating of 'G' and a length of less than 1 hour, setting the new rate to be $1.50.

UPDATE film
SET rental_rate = 1.50
WHERE rating = 'G' AND length < 60;

SELECT title, rental_rate
FROM film
WHERE rating = 'G' AND length < 60;

-- 4.11: Write a SQL query to update the salary of all employees in the database sakila and  explain details based on their job title and years of experience, setting the new salary to be equal to the current salary multiplied by a factor that depends on their job title and years of experience.
-- UPDATE sakila.employee e
-- SET e.salary = 
--     CASE e.job_title
--         WHEN 'Manager' THEN e.salary * (1 + 0.1 * FLOOR(e.years_of_experience / 5))
--         WHEN 'Sales Associate' THEN e.salary * (1 + 0.05 * FLOOR(e.years_of_experience / 3))
--         ELSE e.salary * (1 + 0.02 * FLOOR(e.years_of_experience / 2))
--     END;

-- 4.13: Write a SQL query to update the rating of all hotels in the database based on their current rating and the average rating of all hotels in the same city, setting the new rating to be equal to the average rating plus a factor that depends on the current rating of the hotel.

-- SELECT film_id, title, rental_rate
-- FROM film
-- WHERE film_id IN (
--     SELECT rental.film_id
--     FROM rental
--     GROUP BY rental.film_id
--     HAVING COUNT(*) > 10
-- )

-- UPDATE film
-- SET rental_rate = LEAST(4.00, rental_rate * 1.05)
-- WHERE film_id IN (
--     SELECT rental.film_id
--     FROM rental
--     GROUP BY rental.film_id
--     HAVING COUNT(*) > 10
-- )

-- 4.14: Write a SQL query to update the status of all orders in the database based on the current status and the number of days that have passed since the order was placed, setting the new status to be equal to 'Shipped' if the number of days is greater than or equal to the estimated shipping time, and 'Processing' otherwise.
-- k tồn tại bảng order
UPDATE orders
SET status = customer
    CASE 
        WHEN (DATEDIFF(NOW(), order_date) >= estimated_shipping_time) THEN 'Shipped'
        ELSE 'Processing'
    END;

-- 4.15: Write a SQL query to update the price of all products in the database based on their current price and the number of times they have been ordered, setting the new price to be equal to the current price times a factor that depends on the number of times they have been ordered.
-- k tồn tại bảng order
UPDATE products
SET price = price * 
    CASE 
        WHEN times_ordered < 5 THEN 1
        WHEN times_ordered >= 5 AND times_ordered < 10 THEN 0.95
        WHEN times_ordered >= 10 AND times_ordered < 20 THEN 0.9
        ELSE 0.85
    END;



